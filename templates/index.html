<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pharaoh Online</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f0f0f0;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }
        .screen {
            display: none;
            flex: 1;
            padding: 10px;
        }
        .screen.active {
            display: flex;
            flex-direction: column;
        }
        .grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(6, 1fr);
            gap: 2px;
            max-width: 400px;
            margin: 0 auto;
        }
        .cell {
            width: 40px;
            height: 40px;
            border: 1px solid #ccc;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            background-color: #795548;
            position: relative;
        }
        .cell.wall {
            background-color: #f4e7be;
        }
        .cell.wall::before {
            content: none;
        }
        .cell.dug {
            background-color: #f4e7be;
        }
        .cell.sand {
            background-color: #f4e7be;
        }
        .cell.ghost-green {
            background-color: #4caf50;
        }
        .cell.ghost-red {
            background-color: #f44336;
        }
        .cell[data-type="2"]::before {
            content: "üêç";
        }
        .cell[data-type="3"]::before {
            content: "üï≥Ô∏è";
        }
        .cell[data-type="4"] {
            background-color: gold;
        }
        .cell[data-type="4"]::before {
            content: "‚ö∞Ô∏è";
        }
        .toolbar {
            display: flex;
            justify-content: space-around;
            margin-bottom: 10px;
        }
        .tool {
            padding: 10px;
            border: 1px solid #ccc;
            cursor: pointer;
            background-color: #fff;
        }
        .tool.active {
            background-color: yellow;
            transform: scale(1.1);
        }
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            display: none;
        }
        .modal.active {
            display: flex;
        }
        .modal-content {
            background-color: #fff;
            padding: 20px;
            border-radius: 5px;
            text-align: center;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            border: none;
            background-color: #007bff;
            color: white;
            cursor: pointer;
        }
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        .timer {
            font-size: 24px;
            text-align: center;
            margin-bottom: 10px;
        }
        .stats {
            margin-bottom: 10px;
        }
        @media (max-width: 600px) {
            .grid {
                max-width: 100%;
            }
            .cell {
                width: 30px;
                height: 30px;
            }
        }
    </style>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
</head>
<body>
    <div id="main-screen" class="screen active">
        <h1>Pharaoh Online</h1>
        <button onclick="showScreen('editor')">–†–µ–¥–∞–∫—Ç–æ—Ä –∫–∞—Ä—Ç</button>
        <button onclick="startRaid()">–ù–∞—á–∞—Ç—å —Ä–µ–π–¥</button>
        <button onclick="showScreen('tombs')">–ú–æ–∏ –≥—Ä–æ–±–Ω–∏—Ü—ã</button>
    </div>

    <div id="editor-screen" class="screen">
        <h2>–†–µ–¥–∞–∫—Ç–æ—Ä –∫–∞—Ä—Ç</h2>
        <div class="toolbar">
            <div class="tool" data-type="snake" onclick="selectTool('snake')">–ó–º–µ—è <span id="snake-count">0/4</span></div>
            <div class="tool" data-type="scarab" onclick="selectTool('scarab')">–î—ã—Ä–∞ <span id="scarab-count">0/2</span></div>
            <div class="tool" data-type="chest" onclick="selectTool('chest')">–°—É–Ω–¥—É–∫ <span id="chest-count">0/1</span></div>
        </div>
        <div id="editor-grid" class="grid"></div>
        <button id="publish-btn" onclick="publishMap()" disabled>–û–ø—É–±–ª–∏–∫–æ–≤–∞—Ç—å</button>
        <button onclick="showScreen('main')">–ù–∞–∑–∞–¥</button>
    </div>

    <div id="gameplay-screen" class="screen">
        <div class="timer" id="timer">120</div>
        <div id="game-grid" class="grid"></div>
        <button onclick="leaveRaid()">–í—ã–π—Ç–∏</button>
    </div>

    <div id="tombs-screen" class="screen">
        <h2>–ú–æ–∏ –≥—Ä–æ–±–Ω–∏—Ü—ã</h2>
        <div id="tombs-list"></div>
        <button onclick="showScreen('main')">–ù–∞–∑–∞–¥</button>
    </div>

    <div id="win-modal" class="modal">
        <div class="modal-content">
            <h3>–ü–æ–±–µ–¥–∞!</h3>
            <button onclick="claimReward()">–ó–∞–±—Ä–∞—Ç—å –¥–µ–Ω—å–≥–∏</button>
            <button onclick="nextStage()">–°–ª–µ–¥—É—é—â–∏–π —ç—Ç–∞–ø</button>
        </div>
    </div>

    <div id="error-modal" class="modal">
        <div class="modal-content">
            <p id="error-message"></p>
            <button onclick="closeModal()">OK</button>
        </div>
    </div>

    <script>
        const tg = window.Telegram?.WebApp;
        const initData = tg ? tg.initData : 'mock_init_data'; // Mock for testing outside Telegram
        console.log('initData:', initData);
        let currentScreen = 'main';
        let editorGrid = [];
        let gameGrid = [];
        let sessionId = null;
        let timerInterval = null;
        let selectedTool = null;
        let pendingIndex = null;

        function showScreen(screen) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            document.getElementById(screen + '-screen').classList.add('active');
            currentScreen = screen;
            if (screen === 'editor') {
                console.log('Loading editor screen');
                loadEditorTemplate();
            } else if (screen === 'tombs') {
                loadTombs();
            }
        }

        async function apiCall(endpoint, data = {}) {
            data.initData = initData;
            try {
                const response = await fetch(endpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(data)
                });
                const result = await response.json();
                if (!response.ok) throw new Error(result.error || 'API error');
                return result;
            } catch (e) {
                showError(e.message);
                throw e;
            }
        }

        function showError(message) {
            document.getElementById('error-message').textContent = message;
            document.getElementById('error-modal').classList.add('active');
        }

        function closeModal() {
            document.querySelectorAll('.modal').forEach(m => m.classList.remove('active'));
        }

        // Editor functions
        async function loadEditorTemplate() {
            const data = await apiCall('/api/editor/template');
            console.log('Editor template loaded:', data);
            editorGrid = data.grid;
            console.log('Editor grid set:', editorGrid);
            renderEditorGrid();
            updateCounts();
        }

        function renderEditorGrid() {
            console.log('Rendering editor grid with', editorGrid.length, 'cells');
            const gridEl = document.getElementById('editor-grid');
            console.log('Grid element:', gridEl);
            gridEl.innerHTML = '';
            editorGrid.forEach((cell, i) => {
                const cellEl = document.createElement('div');
                cellEl.className = 'cell';
                cellEl.dataset.type = cell;
                if (cell === 0) cellEl.classList.add('wall');
                cellEl.dataset.index = i;
                cellEl.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    pendingIndex = i;
                    showGhost(i);
                });
                cellEl.addEventListener('mouseenter', () => {
                    if (pendingIndex !== null) {
                        showGhost(i);
                    }
                });
                cellEl.addEventListener('mouseleave', () => hideGhost());
                cellEl.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    pendingIndex = i;
                    showGhost(i);
                });
                cellEl.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    const target = document.elementFromPoint(touch.clientX, touch.clientY);
                    if (target && target.dataset.index) {
                        showGhost(parseInt(target.dataset.index));
                    }
                });
                gridEl.appendChild(cellEl);
            });
            document.addEventListener('mouseup', () => {
                if (pendingIndex !== null) {
                    commitPlacement(pendingIndex);
                    pendingIndex = null;
                    hideGhost();
                }
            });
            document.addEventListener('touchend', () => {
                if (pendingIndex !== null) {
                    commitPlacement(pendingIndex);
                    pendingIndex = null;
                    hideGhost();
                }
            });
            console.log('Grid rendered');
        }

        function selectTool(tool) {
            selectedTool = tool;
            pendingIndex = null;
            hideGhost();
            document.querySelectorAll('.tool').forEach(t => t.classList.remove('active'));
            if (tool) document.querySelector(`[data-type="${tool}"]`).classList.add('active');
            if (tg && tg.HapticFeedback) tg.HapticFeedback.selectionChanged();
        }

        function commitPlacement(index) {
            if (editorGrid[index] === 0) return; // wall
            if (!selectedTool) return;

            const type = selectedTool === 'snake' ? 2 : selectedTool === 'scarab' ? 3 : 4;
            let action = 'set'; // set, replace, remove
            let haptic = 'medium';

            if (selectedTool === 'chest') {
                // Smart chest: try horizontal, then vertical
                const row = Math.floor(index / 8);
                const col = index % 8;
                let secondIndex = null;
                if (col < 7 && editorGrid[index + 1] === 1) {
                    secondIndex = index + 1;
                } else if (row < 5 && editorGrid[index + 8] === 1) {
                    secondIndex = index + 8;
                }
                if (secondIndex === null) return; // can't place

                if (editorGrid[index] === 4 && editorGrid[secondIndex] === 4) {
                    // remove
                    editorGrid[index] = 1;
                    editorGrid[secondIndex] = 1;
                    action = 'remove';
                    haptic = 'light';
                } else if (editorGrid[index] === 1 && editorGrid[secondIndex] === 1) {
                    // set
                    editorGrid[index] = 4;
                    editorGrid[secondIndex] = 4;
                    haptic = 'heavy';
                }
            } else {
                if (editorGrid[index] === 1) {
                    // set
                    editorGrid[index] = type;
                } else if (editorGrid[index] === type) {
                    // remove
                    editorGrid[index] = 1;
                    action = 'remove';
                    haptic = 'light';
                } else {
                    // replace
                    editorGrid[index] = type;
                }
            }

            updateCounts();
            renderEditorGrid();
            if (tg && tg.HapticFeedback) tg.HapticFeedback.impactOccurred(haptic);
        }


        function showGhost(index) {
            hideGhost();
            if (!selectedTool) return;
            const cells = [index];
            if (selectedTool === 'chest') {
                const second = getChestSecondIndex(index);
                if (second !== null) cells.push(second);
            }
            cells.forEach(i => {
                const cellEl = document.querySelector(`[data-index="${i}"]`);
                if (editorGrid[i] === 1) {
                    cellEl.classList.add('ghost-green');
                } else {
                    cellEl.classList.add('ghost-red');
                }
            });
        }

        function hideGhost() {
            document.querySelectorAll('.cell').forEach(c => {
                c.classList.remove('ghost-green', 'ghost-red');
            });
        }

        function getChestSecondIndex(index) {
            if (editorGrid[index] !== 1) return null;
            const row = Math.floor(index / 8);
            const col = index % 8;
            let second = null;
            if (col < 7 && editorGrid[index + 1] === 1) {
                second = index + 1;
            } else if (row < 5 && editorGrid[index + 8] === 1) {
                second = index + 8;
            }
            return second;
        }

        function updateCounts() {
            const snakes = editorGrid.filter(c => c === 2).length;
            const scarabs = editorGrid.filter(c => c === 3).length;
            const chests = Math.floor(editorGrid.filter(c => c === 4).length / 2);
            document.getElementById('snake-count').textContent = `${snakes}/4`;
            document.getElementById('scarab-count').textContent = `${scarabs}/2`;
            document.getElementById('chest-count').textContent = `${chests}/1`;
            document.getElementById('publish-btn').disabled = !(snakes === 4 && scarabs === 2 && chests === 1);
        }

        async function publishMap() {
            await apiCall('/api/maps/create', { grid: editorGrid });
            showScreen('main');
        }

        // Gameplay functions
        async function startRaid() {
            const scout = await apiCall('/api/raid/scout');
            const start = await apiCall('/api/raid/start', { map_id: scout.map_id });
            sessionId = start.session_id;
            gameGrid = new Array(48).fill(1);
            start.walls.forEach(i => gameGrid[i] = 0);
            showScreen('gameplay');
            startTimer();
            renderGameGrid();
        }

        function renderGameGrid() {
            const gridEl = document.getElementById('game-grid');
            gridEl.innerHTML = '';
            gameGrid.forEach((cell, i) => {
                const cellEl = document.createElement('div');
                cellEl.className = 'cell';
                cellEl.dataset.type = cell;
                if (cell === 0) cellEl.classList.add('wall');
                else if (cell === 2) cellEl.classList.add('dug'); // assume dug if not wall
                else cellEl.classList.add('sand');
                if (cell !== 0 && cell !== 2) {
                    cellEl.addEventListener('click', () => dig(i));
                }
                gridEl.appendChild(cellEl);
            });
        }

        async function dig(index) {
            // loading
            const cellEl = document.querySelector(`#game-grid .cell:nth-child(${index + 1})`);
            cellEl.innerHTML = '<div>‚è≥</div>';
            try {
                const result = await apiCall('/api/raid/dig', { session_id: sessionId, cell_index: index });
                if (result.status === 'dead') {
                    showError('–í—ã –ø–æ–≥–∏–±–ª–∏!');
                    showScreen('main');
                } else if (result.status === 'hurt') {
                    showError('–†–∞–Ω–µ–Ω —Å–∫–∞—Ä–∞–±–µ–µ–º!');
                    showScreen('main');
                } else if (result.status === 'safe') {
                    gameGrid[index] = 2; // dug
                    renderGameGrid();
                    if (result.stage_complete) {
                        document.getElementById('win-modal').classList.add('active');
                    }
                }
            } catch (e) {
                cellEl.innerHTML = '';
            }
        }

        function startTimer() {
            let time = 120;
            timerInterval = setInterval(() => {
                time--;
                document.getElementById('timer').textContent = time;
                if (time <= 0) {
                    clearInterval(timerInterval);
                    leaveRaid();
                }
            }, 1000);
        }

        async function leaveRaid() {
            if (timerInterval) clearInterval(timerInterval);
            await apiCall('/api/raid/leave', { session_id: sessionId });
            showScreen('main');
        }

        async function claimReward() {
            await apiCall('/api/raid/leave', { session_id: sessionId });
            closeModal();
            showScreen('main');
        }

        async function nextStage() {
            // assume next stage logic, but since not specified, just restart
            closeModal();
            startRaid();
        }

        // Tombs functions
        async function loadTombs() {
            const data = await apiCall('/api/my_tombs');
            const listEl = document.getElementById('tombs-list');
            listEl.innerHTML = '';
            data.tombs.forEach(tomb => {
                const div = document.createElement('div');
                div.innerHTML = `<p>–ö–∞—Ä—Ç–∞ ${tomb.id}: –£–±–∏—Ç–æ ${tomb.deaths}, –ó–∞—Ä–∞–±–æ—Ç–∞–Ω–æ ${tomb.earnings}</p>
                <button onclick="claimTombReward(${tomb.id})" ${tomb.can_claim ? '' : 'disabled'}>–ó–∞–±—Ä–∞—Ç—å –Ω–∞–≥—Ä–∞–¥—É</button>`;
                listEl.appendChild(div);
            });
        }

        async function claimTombReward(id) {
            await apiCall('/api/my_tombs/claim', { map_id: id });
            loadTombs();
        }

        // Init
        if (tg) tg.ready();
        apiCall('/api/login'); // login on start
    </script>
</body>
</html>