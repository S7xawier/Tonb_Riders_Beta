<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pharaoh Online</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f0f0f0;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }
        .screen {
            display: none;
            flex: 1;
            padding: 10px;
        }
        .screen.active {
            display: flex;
            flex-direction: column;
        }
        .grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(6, 1fr);
            gap: 2px;
            max-width: 400px;
            margin: 0 auto;
        }
        .cell {
            width: 40px;
            height: 40px;
            border: 1px solid #ccc;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            background-color: #795548;
            position: relative;
        }
        .cell.wall {
            background-color: #f4e7be;
        }
        .cell.wall::before {
            content: none;
        }
        .cell.dug {
            background-color: #f4e7be;
        }
        .cell.sand {
            background-color: #f4e7be;
        }
        .cell.dug {
            background-color: #5d4037;
        }
        .cell.ghost-green {
            background-color: #4caf50;
        }
        .cell.ghost-red {
            background-color: #f44336;
        }
        .cell[data-type="2"]::before {
            content: "üíÄ";
        }
        .cell[data-type="3"]::before {
            content: "üï≥Ô∏è";
        }
        .cell[data-type="4"] {
            background-color: gold;
        }
        .cell[data-type="4"]::before {
            content: "‚ö∞Ô∏è";
        }
        .toolbar {
            display: flex;
            justify-content: space-around;
            margin-bottom: 10px;
        }
        .tool {
            padding: 10px;
            border: 1px solid #ccc;
            cursor: pointer;
            background-color: #fff;
        }
        .tool.active {
            background-color: yellow;
            transform: scale(1.1);
        }
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            display: none;
        }
        .modal.active {
            display: flex;
        }
        .modal-content {
            background-color: #fff;
            padding: 20px;
            border-radius: 5px;
            text-align: center;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            border: none;
            background-color: #007bff;
            color: white;
            cursor: pointer;
        }
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        .timer {
            font-size: 24px;
            text-align: center;
            margin-bottom: 10px;
        }
        .stats {
            margin-bottom: 10px;
        }
        @media (max-width: 600px) {
            .grid {
                max-width: 100%;
            }
            .cell {
                width: 30px;
                height: 30px;
            }
        }
    </style>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
</head>
<body>
    <div id="main-screen" class="screen active">
        <h1>Pharaoh Online</h1>
        <button onclick="showScreen('editor')">–†–µ–¥–∞–∫—Ç–æ—Ä –∫–∞—Ä—Ç</button>
        <button onclick="startRaid()">–ù–∞—á–∞—Ç—å —Ä–µ–π–¥</button>
        <button onclick="showScreen('tombs')">–ú–æ–∏ –≥—Ä–æ–±–Ω–∏—Ü—ã</button>
    </div>

    <div id="editor-screen" class="screen">
        <h2>–†–µ–¥–∞–∫—Ç–æ—Ä –∫–∞—Ä—Ç</h2>
        <div class="toolbar">
            <div class="tool" data-type="snake" onclick="selectTool('snake')">–ó–º–µ—è <span id="snake-count">0/4</span></div>
            <div class="tool" data-type="scarab" onclick="selectTool('scarab')">–î—ã—Ä–∞ <span id="scarab-count">0/2</span></div>
            <div class="tool" data-type="chest" onclick="selectTool('chest')">–°—É–Ω–¥—É–∫ <span id="chest-count">0/1</span></div>
        </div>
        <div id="editor-grid" class="grid"></div>
        <button id="publish-btn" onclick="publishMap()" disabled>–û–ø—É–±–ª–∏–∫–æ–≤–∞—Ç—å</button>
        <button onclick="showScreen('main')">–ù–∞–∑–∞–¥</button>
    </div>

    <div id="gameplay-screen" class="screen">
        <div class="timer" id="timer">120</div>
        <div id="game-grid" class="grid"></div>
        <button onclick="leaveRaid()">–í—ã–π—Ç–∏</button>
    </div>

    <div id="tombs-screen" class="screen">
        <h2>–ú–æ–∏ –≥—Ä–æ–±–Ω–∏—Ü—ã</h2>
        <div id="tombs-list"></div>
        <button onclick="showScreen('main')">–ù–∞–∑–∞–¥</button>
    </div>

    <div id="scout-screen" class="screen">
        <h2>–†–∞–∑–≤–µ–¥–∫–∞</h2>
        <div id="scout-preview" class="grid"></div>
        <div class="stats">
            <p>–°–º–µ—Ä—Ç–µ–π: <span id="scout-deaths">0</span></p>
            <p>–ü–æ–±–µ–¥: <span id="scout-wins">0</span></p>
            <p>–°—Ç–æ–∏–º–æ—Å—Ç—å –≤—Ö–æ–¥–∞: <span id="scout-fee">0.0</span></p>
        </div>
        <button onclick="scoutAnother()">–ò—Å–∫–∞—Ç—å –¥—Ä—É–≥—É—é –∫–∞—Ä—Ç—É</button>
        <button onclick="startRaidFromScout()">–ì—Ä–∞–±–∏—Ç—å —ç—Ç—É –∫–∞—Ä—Ç—É</button>
        <button onclick="showScreen('main')">–ù–∞–∑–∞–¥</button>
    </div>

    <div id="win-modal" class="modal">
        <div class="modal-content">
            <h3>–ü–æ–±–µ–¥–∞!</h3>
            <button onclick="claimReward()">–ó–∞–±—Ä–∞—Ç—å –¥–µ–Ω—å–≥–∏</button>
            <button onclick="nextStage()">–°–ª–µ–¥—É—é—â–∏–π —ç—Ç–∞–ø</button>
        </div>
    </div>

    <div id="error-modal" class="modal">
        <div class="modal-content">
            <p id="error-message"></p>
            <button onclick="closeModal()">OK</button>
        </div>
    </div>

    <script>
        const tg = window.Telegram?.WebApp;
        const initData = tg ? tg.initData : 'mock_init_data'; // Mock for testing outside Telegram
        console.log('initData:', initData);
        let currentScreen = 'main';
        let editorGrid = [];
        let gameGrid = [];
        let sessionId = null;
        let timerInterval = null;
        let selectedTool = null;
        let pendingIndex = null;
        let ghostIndex = null;
        let potentialPlacement = [];
        let isValidPlacement = false;
        let scoutData = null;

        function showScreen(screen) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            document.getElementById(screen + '-screen').classList.add('active');
            currentScreen = screen;
            if (screen === 'editor') {
                console.log('Loading editor screen');
                loadEditorTemplate();
            } else if (screen === 'tombs') {
                loadTombs();
            }
        }

        async function apiCall(endpoint, data = {}) {
            data.initData = initData;
            try {
                const response = await fetch(endpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(data)
                });
                const result = await response.json();
                if (!response.ok) throw new Error(result.error || 'API error');
                return result;
            } catch (e) {
                showError(e.message);
                throw e;
            }
        }

        function showError(message) {
            document.getElementById('error-message').textContent = message;
            document.getElementById('error-modal').classList.add('active');
        }

        function closeModal() {
            document.querySelectorAll('.modal').forEach(m => m.classList.remove('active'));
        }

        // Editor functions
        async function loadEditorTemplate() {
            const data = await apiCall('/api/editor/template');
            console.log('Editor template loaded:', data);
            editorGrid = data.grid;
            console.log('Editor grid set:', editorGrid);
            renderEditorGrid();
            updateCounts();
        }

        function renderEditorGrid() {
            console.log('Rendering editor grid with', editorGrid.length, 'cells');
            const gridEl = document.getElementById('editor-grid');
            console.log('Grid element:', gridEl);
            gridEl.innerHTML = '';
            editorGrid.forEach((cell, i) => {
                const cellEl = document.createElement('div');
                cellEl.className = 'cell';
                cellEl.dataset.type = cell;
                if (cell === 0) cellEl.classList.add('wall');
                cellEl.dataset.index = i;
                cellEl.addEventListener('mousedown', (e) => {
                    if (selectedTool) {
                        e.preventDefault();
                        pendingIndex = i;
                    }
                });
                cellEl.addEventListener('touchstart', (e) => {
                    if (selectedTool) {
                        e.preventDefault();
                        pendingIndex = i;
                    }
                });
                gridEl.appendChild(cellEl);
            });
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('touchmove', handleTouchMove, { passive: false });
            document.addEventListener('mouseup', () => {
                if (isValidPlacement) {
                    commitPotentialPlacement();
                }
                clearGhost();
            });
            document.addEventListener('touchend', () => {
                if (isValidPlacement) {
                    commitPotentialPlacement();
                }
                clearGhost();
            });
            console.log('Grid rendered');
        }

        function handleMouseMove(e) {
            if (pendingIndex === null || !selectedTool) return;
            e.preventDefault();
            const target = document.elementFromPoint(e.clientX, e.clientY);
            updateGhostFromTarget(target);
        }

        function handleTouchMove(e) {
            if (pendingIndex === null || !selectedTool) return;
            e.preventDefault();
            const touch = e.touches[0];
            const target = document.elementFromPoint(touch.clientX, touch.clientY);
            updateGhostFromTarget(target);
        }

        function updateGhostFromTarget(target) {
            clearGhost();
            if (!target || !target.classList.contains('cell') || !target.dataset.index) {
                ghostIndex = null;
                potentialPlacement = [];
                isValidPlacement = false;
                return;
            }
            ghostIndex = parseInt(target.dataset.index);
            potentialPlacement = calculatePotentialPlacement(ghostIndex);
            isValidPlacement = potentialPlacement.length > 0 && potentialPlacement.every(i => editorGrid[i] !== 0);
            if (selectedTool === 'chest' && potentialPlacement.length === 2) {
                const [i1, i2] = potentialPlacement;
                isValidPlacement = isValidPlacement && ((editorGrid[i1] === 1 && editorGrid[i2] === 1) || (editorGrid[i1] === 4 && editorGrid[i2] === 4));
            }
            applyGhostClasses();
        }

        function calculatePotentialPlacement(index) {
            if (!selectedTool) return [];
            if (selectedTool === 'chest') {
                const row = Math.floor(index / 8);
                const col = index % 8;
                let placements = [index];
                let second = null;
                if (col < 7 && editorGrid[index + 1] !== 0) { // not wall
                    second = index + 1;
                } else if (row < 5 && editorGrid[index + 8] !== 0) {
                    second = index + 8;
                }
                if (second !== null) placements.push(second);
                return placements;
            } else {
                return [index];
            }
        }

        function applyGhostClasses() {
            potentialPlacement.forEach(i => {
                const cellEl = document.querySelector(`[data-index="${i}"]`);
                if (cellEl) {
                    if (isValidPlacement) {
                        cellEl.classList.add('ghost-green');
                    } else {
                        cellEl.classList.add('ghost-red');
                    }
                }
            });
        }

        function clearGhost() {
            document.querySelectorAll('.cell').forEach(c => {
                c.classList.remove('ghost-green', 'ghost-red');
            });
            ghostIndex = null;
            potentialPlacement = [];
            isValidPlacement = false;
        }

        function commitPotentialPlacement() {
            if (!isValidPlacement || potentialPlacement.length === 0) return;
            if (selectedTool === 'chest') {
                const [i1, i2] = potentialPlacement;
                if (editorGrid[i1] === 4 && editorGrid[i2] === 4) {
                    // remove
                    editorGrid[i1] = 1;
                    editorGrid[i2] = 1;
                    if (tg && tg.HapticFeedback) tg.HapticFeedback.impactOccurred('light');
                } else if (editorGrid[i1] === 1 && editorGrid[i2] === 1) {
                    // set
                    editorGrid[i1] = 4;
                    editorGrid[i2] = 4;
                    if (tg && tg.HapticFeedback) tg.HapticFeedback.impactOccurred('heavy');
                }
            } else {
                const type = selectedTool === 'snake' ? 2 : selectedTool === 'scarab' ? 3 : 4;
                potentialPlacement.forEach(i => {
                    if (editorGrid[i] === 1) {
                        editorGrid[i] = type;
                    } else if (editorGrid[i] === type) {
                        editorGrid[i] = 1;
                    } else {
                        editorGrid[i] = type;
                    }
                });
                if (tg && tg.HapticFeedback) tg.HapticFeedback.impactOccurred('medium');
            }
            updateCounts();
            renderEditorGrid();
        }

        function selectTool(tool) {
            selectedTool = tool;
            pendingIndex = null;
            clearGhost();
            document.querySelectorAll('.tool').forEach(t => t.classList.remove('active'));
            if (tool) document.querySelector(`[data-type="${tool}"]`).classList.add('active');
            if (tg && tg.HapticFeedback) tg.HapticFeedback.selectionChanged();
        }


        function updateCounts() {
            const snakes = editorGrid.filter(c => c === 2).length;
            const scarabs = editorGrid.filter(c => c === 3).length;
            const chests = Math.floor(editorGrid.filter(c => c === 4).length / 2);
            document.getElementById('snake-count').textContent = `${snakes}/4`;
            document.getElementById('scarab-count').textContent = `${scarabs}/2`;
            document.getElementById('chest-count').textContent = `${chests}/1`;
            document.getElementById('publish-btn').disabled = !(snakes === 4 && scarabs === 2 && chests === 1);
        }

        async function publishMap() {
            await apiCall('/api/maps/create', { grid: editorGrid });
            showScreen('main');
        }

        // Gameplay functions
        async function startRaid() {
            scoutData = await apiCall('/api/raid/scout');
            showScreen('scout');
            await renderScout();
        }

        async function renderScout() {
            if (!scoutData) return;
            const preview = await apiCall('/api/raid/preview', { map_id: scoutData.map_id });
            const gridEl = document.getElementById('scout-preview');
            gridEl.innerHTML = '';
            preview.safe_grid.forEach((cell, i) => {
                const cellEl = document.createElement('div');
                cellEl.className = 'cell';
                if (cell === 1) cellEl.classList.add('wall');
                else cellEl.classList.add('sand');
                gridEl.appendChild(cellEl);
            });
            document.getElementById('scout-deaths').textContent = preview.stats.deaths;
            document.getElementById('scout-wins').textContent = preview.stats.wins;
            document.getElementById('scout-fee').textContent = preview.fee;
        }

        async function scoutAnother() {
            scoutData = await apiCall('/api/raid/scout');
            await renderScout();
        }

        async function startRaidFromScout() {
            if (!scoutData) return;
            const start = await apiCall('/api/raid/start', { map_id: scoutData.map_id });
            sessionId = start.session_id;
            gameGrid = start.safe_grid;
            showScreen('gameplay');
            if (start.expires_at) {
                const remaining = Math.max(0, Math.floor((new Date(start.expires_at) - new Date()) / 1000));
                startTimer(remaining);
            } else {
                startTimer();
            }
            renderGameGrid();
        }

        function renderGameGrid() {
            const gridEl = document.getElementById('game-grid');
            gridEl.innerHTML = '';
            gameGrid.forEach((cell, i) => {
                const cellEl = document.createElement('div');
                cellEl.className = 'cell';
                cellEl.dataset.type = cell;
                if (cell === 9) {
                    cellEl.classList.add('sand');
                    cellEl.addEventListener('click', () => dig(i));
                    cellEl.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        dig(i);
                    });
                } else if (cell === 1) {
                    cellEl.classList.add('wall');
                } else {
                    cellEl.classList.add('dug');
                }
                gridEl.appendChild(cellEl);
            });
        }

        async function dig(index) {
            // loading
            const cellEl = document.querySelector(`#game-grid .cell:nth-child(${index + 1})`);
            cellEl.innerHTML = '<div>‚è≥</div>';
            try {
                const result = await apiCall('/api/raid/dig', { session_id: sessionId, cell_index: index });
                if (result.status === 'dead') {
                    gameGrid[index] = result.cell_type;
                    renderGameGrid();
                    setTimeout(() => {
                        showError('–í—ã –ø–æ–≥–∏–±–ª–∏!');
                        showScreen('main');
                    }, 1000);
                } else if (result.status === 'hurt') {
                    showError('–†–∞–Ω–µ–Ω —Å–∫–∞—Ä–∞–±–µ–µ–º!');
                    showScreen('main');
                } else if (result.status === 'safe') {
                    gameGrid[index] = result.cell_type;
                    renderGameGrid();
                    if (result.stage_complete) {
                        document.getElementById('win-modal').classList.add('active');
                    }
                }
            } catch (e) {
                cellEl.innerHTML = '';
            }
        }

        function startTimer(initialTime = 120) {
            let time = initialTime;
            timerInterval = setInterval(() => {
                time--;
                document.getElementById('timer').textContent = time;
                if (time <= 0) {
                    clearInterval(timerInterval);
                    leaveRaid();
                }
            }, 1000);
        }

        async function leaveRaid() {
            if (timerInterval) clearInterval(timerInterval);
            await apiCall('/api/raid/leave', { session_id: sessionId });
            showScreen('main');
        }

        async function claimReward() {
            await apiCall('/api/raid/leave', { session_id: sessionId });
            closeModal();
            showScreen('main');
        }

        async function nextStage() {
            // assume next stage logic, but since not specified, just restart
            closeModal();
            startRaid();
        }

        // Tombs functions
        async function loadTombs() {
            const data = await apiCall('/api/my_tombs');
            const listEl = document.getElementById('tombs-list');
            listEl.innerHTML = '';
            data.tombs.forEach(tomb => {
                const div = document.createElement('div');
                div.innerHTML = `<p>–ö–∞—Ä—Ç–∞ ${tomb.id}: –£–±–∏—Ç–æ ${tomb.deaths}, –ó–∞—Ä–∞–±–æ—Ç–∞–Ω–æ ${tomb.earnings}</p>
                <button onclick="claimTombReward(${tomb.id})" ${tomb.can_claim ? '' : 'disabled'}>–ó–∞–±—Ä–∞—Ç—å –Ω–∞–≥—Ä–∞–¥—É</button>`;
                listEl.appendChild(div);
            });
        }

        async function claimTombReward(id) {
            await apiCall('/api/my_tombs/claim', { map_id: id });
            loadTombs();
        }

        // Init
        if (tg) tg.ready();
        apiCall('/api/login'); // login on start
    </script>
</body>
</html>